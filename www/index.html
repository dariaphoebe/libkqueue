<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="en-us" />

    <title>libkqueue</title>
    <style type="text/css">
    body {
        background:	#DCDCDC;
        margin: 0;
    }
    div.content {
        background: white;
        margin: 0 3em;
        padding: 0 2em;
    }
    .blockquote { margin-right: 2em }
    code.block { 
         padding: 10px; 
         border: 1px solid black; 
         background: beige;
         margin: 2em; 
    }
    h1 {
        font-size: 3em;
        color: maroon;
        text-align: center;
    }
    h2 {
        margin-left: -1em;
        padding-top: 0.5em;
    }
    ol {
        margin: 2em;
    }
    li {
        padding-bottom: 10px;
    }
    p {
        padding-bottom: 10px;
    } 
    </style>
</head>

<body>

<div class="content">
<h1>libkqueue</h1>

<h2>Overview</h2>
libkqueue is a userspace implementation of the <a href="http://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2">kqueue(2)</a> kernel event notification mechanism. Initial efforts are focused on porting to the Linux 2.6 kernel. There is also an experimental Solaris port.

<p>
libkqueue acts as a translator between the <code>kevent</code> structure and the native kernel facilities of the host machine. The following diagram illustrates how this works under Linux: 
</p>

<p align=center>
<img src="linux_impl.png" border=0>
</p>

<h2>Benchmarks</h2>
On Linux, libkqueue provides O(1) scalability relative to the number of concurrent client connections. This is an improvement over the traditional <code>poll(2)</code> system call which has O(N) scalability. For testing, two versions of the <a href="http://www.acme.com/software/thttpd/">thttpd web server</a> were compiled: one using libkqueue, and one using poll(2). The ApacheBench benchmarking utility was used to compare the performance of both versions. A custom script was used to create thousands of idle connections to the server, to simulate the use of HTTP Keepalives on a busy real-world server. 
<p align=center>
<img src="scalability.png" border=0>
</p>

<h2>Download</h2>

Source code releases can be found <a href="dist">here</a>. There are no binary packages yet.
<p>
To checkout the Subversion repository, run the following command:
<p>
<code class=block>svn checkout svn://mark.heily.com/libkqueue</code>

<h2>Mailing Lists</h2>

There are two mailing lists: one for general discussion, and one for announcements.  If you subscribe to a mailing list through the web interface, you will need to sign up for a free Google account. If you prefer not to create a Google account, you can subscribe via email instead.
<p>
To subscribe to the general discussion group, visit the group's <a href="http://groups.google.com/group/libkqueue">web interface</a>, or send an email to <a href="mailto:libkqueue+subscribe@googlegroups.com">libkqueue+subscribe@googlegroups.com</a>. 
<p>
To subscribe to the low-traffic annoucements-only group, visit the group's <a href="http://groups.google.com/group/libkqueue-announce">web interface</a>, or send an email to <a href="mailto:libkqueue-announce+subscribe@googlegroups.com">libkqueue-announce+subscribe@googlegroups.com</a>. 
<p>
Please note that if you use multiple email addresses, Google Groups does not allow you to choose which email address will receive messages. The address on the <code>From:</code> line of the subscribe request will be used as the destination address.
<p>
To unsubscribe from either group, send an email to <code>[group name]+unsubscribe@googlegroups.com</code>. If you have any problems subscribing or unsubscribing, send a note to <a href="mailto:devel+libkqueue@heily.com">Mark Heily</a>.

<h2>Status</h2>

The kqueue and kevent functions are implemented, and most of the filters are working. The following filters are not yet implemented:<p>

<ul>
 <li><code>EVFILT_PROC</code>
 <li><code>EVFILT_AIO</code>
</ul>

More details about the current implementation status can be found <a href="status.html">here</a>.
<p>
<h3>Status: Linux</h3>
There are several compatibility issues to be aware of when using this library under Linux:<br>

<ol>

<li>The NOTE_LOWAT flag is not supported. According to <i>socket(7)</i>,<br>
<pre style="blockquote">
"The select(2) and poll(2) system  calls  currently  do not respect the 
SO_RCVLOWAT setting on Linux, and mark a socket readable when even  a  
single  byte  of data is available.  A subsequent read from the socket 
will block until SO_RCVLOWAT bytes are available."</pre>
</li>

<li>
The NOTE_REVOKE flag is not supported because Linux does not have
a <code>revoke(2)</code> system call.
</li>

<li>
When an EVFILT_SIGNAL event is generated, the <code>data</code> field 
is set to 1 regardless of how many times the signal was received by the process.
</li>

<li>
When an EVFILT_READ event occurs on a listening socket, the   <code>data</code> field is set to 1 regardless of how many pending connections are available.

<!--
<li>
The EVFILT_PROC filter only supports the NOTE_EXIT flag, and the <code>ident</code> field must contain the PID of a child of the current process. This filter is only suitable as an event-driven replacement for the <code>wait(2)</code> family of system calls.
</li>
-->

</ol>

<h3>Status: Solaris</h3>
Here are the issues to be aware of when using this library under Solaris:<br>

<ol>
<li>Solaris 10 or newer is required.</li>
<li>The EVFILT_TIMER filter is implemented using high-resolution timers. In order to use high-resolution timers, the calling process must hold the PRIV_PROC_CLOCK_HIGHRES privilege. This privilege is not granted to ordinary users by default. It can be granted to individual users by running the following command as root:<br>
<pre>
# usermod -K defaultpriv=basic,proc_clock_highres $user
</pre>
</ol>

<h3>Status: All Platforms</h3>
Here are the issues to be aware of when using this library under any platform:<br>

<ol>
<li>When a kqueue descriptor is closed, it's resources are not immediately reclaimed. Instead,
    they will be freed the next time that the <code>kqueue(2)</code> function is called.
</li>    

<li>
A signal handler is implicitly installed when a EVFILT_SIGNAL kevent is created. For compatibility with kernel-based <code>kqueue(2)</code>, programs must ignore signals that will generate kevents. After an EVFILT_SIGNAL kevent is created, a program must not modify the disposition of the associated signal. The following example shows the proper way to handle SIGUSR1 with a kevent:<p>
<pre>
int main() {
  int kqfd;
  struct kevent kev;

  kqfd = kqueue();
  signal(SIGUSR1, SIG_IGN);
  EV_SET(&kev, SIGUSR1, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
  kevent(kqfd, &kev, 1, NULL, 0, NULL);
}
</pre>
</ol>

<h2>Future Plans</h2>

In the future, I plan to add three more backends. One will be for Solaris and take advantage of the event port mechanism described in <a href="http://docs.sun.com/app/docs/doc/816-5168/port-create-3c?l=en&a=view&q=port_create">port_create(3C)</a>. The second will be a generic POSIX backend that does not use any non-portable system calls. The third will be a Microsoft Windows port that uses <code>WaitForMultipleObjects()</code>.

<h2>Bugs</h2>

If you suspect that you have found a bug in libkqueue, please send an email report to the mailing list. If you can reproduce the bug, write a simple testcase and enable debugging output by setting the <code>KQUEUE_DEBUG=y</code> environment variable. Provide this debugging output and the code for the testcase in your bug report.

<h2>Portability of kevent(2) across BSD systems</h2>

There are some differences in the behavior of the <code>kevent(2)</code> system call across the various BSD-based operating systems. Here are some of the differences to be aware of:

<ol>

<li>FreeBSD 8 does not set the <i>EV_ADD</i> flag for kevents on the eventlist, but OpenBSD and Darwin do. This means you should never use the equality operator (==) to test the flags; use the logical AND operator instead.
</li>

<li>The <code>EVFILT_USER</code> filter behaves differently from other filters with respect to the <i>EV_ONESHOT</i> flag. All other filters will preserve the flag when the event is triggered and placed on the eventlist. The <code>EVFILT_USER</code> filter does not preserve this flag.
</li>

<li>
OpenBSD has the <i>NOTE_TRUNCATE</i> fflag, while FreeBSD and Darwin do not.
</li>

<li>
EVFILT_FS is undocumented and only available on FreeBSD and Darwin. Here is the <a href="http://adam.kungfoohampster.com/lists/cvs-all/msg71399.shtml">CVS commit log</a> which could be helpful to document this filter.
</li>
<!--
<li>
[TODO - Verify and check against 10.6] OS X 10.5 and earlier do not implement the <code>EVFILT_AIO</code> or <code>EVFILT_TIMER</code> filters.
</li>
-->

</ol>


<h2>Requirements</h2>

libkqueue currently requires the following:

<ul>
<li>GCC
<li>Linux 2.6.22 or higher
<li>glibc 2.8 or higher
</ul>

The Solaris port requires Solaris 10 or higher, and uses the GNU compiler and toolchain.

<h2>Usage</h2>


<h3>Ordinary Makefile</h3>

Here are the steps to use libkqueue in your program if you use an ordinary Makefile:

<ol>
<li>Add <code>`pkg-config libkqueue --cflags`</code> to the CFLAGS variable.
<li>Add <code>`pkg-config libkqueue --libs`</code> to the LDADD variable.
<li>Add <code>#include &lt;sys/event.h&gt;</code> to the source code.
</ol>
<p>

<h3>Autoconf/Automake/Libtool</h3>

If your program uses the GNU Autoconf/Automake/Libtool build system, the following steps will allow you to use libkqueue:

<ol>

<li>Add the following to <code>configure.ac</code>:
<pre>
#
# Prefer native kqueue(2); otherwise use libkqueue if present.
#
AC_CHECK_HEADER(sys/event.h, [],
  [PKG_CHECK_MODULES(KQUEUE, libkqueue)]
)
</pre>
</li>

<li>
Add the following to <code>Makefile.am</code> (assuming your program is named "foo"):
<pre>
foo_CFLAGS+=$(KQUEUE_CFLAGS)
foo_LDADD+=$(KQUEUE_LIBS)
</pre>
</li>
</ol>    

<p>Instead of using the <code>$(KQUEUE_LIBS)</code> variable, you could just add <code>libkqueue.la</code> to your programs LDADD variable.

<h3>Threads</h3>

libkqueue uses one or more helper threads, so all programs that link with libkqueue must also link against the pthreads library. Calls to <code>kqueue()</code> and <code>kevent()</code> are safe to be used from multiple threads.

<h2>Links</h2>

<ul>

<li>
 <a href="http://people.freebsd.org/~jlemon/papers/kqueue.pdf">Kqueue: A generic and scalable event notification facility</a> [Lemon][PDF]
</li>

<li><a href="http://doc.geoffgarside.co.uk/kqueue/">Kqueues for Fun and Profit</a> [Werner]</li>
</ul>

<li>
<a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/tools/tests/xnu_quick_test/kqueue_tests.c">XNU kqueue test program</a> - Demonstrates use of EVFILT_USER
</li>

<li>
<a href="http://www.fsl.cs.sunysb.edu/~kolya/projects/">kqueue for linux</a> - abandoned port of kqueue to Linux circa 2002 <a href="http://www.fsl.cs.sunysb.edu/~kolya/pubs/kqueue_for_linux.pdf">[PDF]</a>.
</li>

<h2>Solaris Event Ports</h2>
I do plan to add Solaris event port support to libkqueue once the Linux backend is complete and the internal API is stabilized. I checked the port_create(3C) manpage in Solaris 10 and OpenSolaris, and did not see any way to wait for signals. There is also no equivalent to EVFILT_VNODE in Solaris 10, although OpenSolaris has the PORT_SOURCE_FILE functionality.
<ul>
<li>
<a href="http://docs.sun.com/app/docs/doc/816-5168/port-create-3c?l=en&a=view&q=port_create">Solaris 10 port_create(3C) manual page</a>
</li>

<li>
<a href="http://docs.sun.com/app/docs/doc/819-2243/port-create-3c?a=view">
OpenSolaris port_create(3C) manual page</a>
</li>


<h2>Contact</h2>
For more information, contact <a href="mailto:devel+libkqueue@heily.com">Mark Heily</a>.

<p>
<hr>
<center>
&copy; 2009 Mark Heily. All rights reserved.
</center>
</div>
</body>
</html>
